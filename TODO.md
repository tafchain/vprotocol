# 第1期待做工作
* c-api要同时支持同步接口和异步接口，以增加二次开发的便利性
* 规划提交事务后的应答该如何处理：
> 1. 注册和发起提案时，增加参数：是否等待处理结果
> 2. 如果不等待处理结果，则背书通过后，即返回给客户应答，具体注册或提案事务是否成功，由用户主动查询
> 3. 如果等待处理结果：则使用选中背书节点所在PEER的处理结果。等待到的处理结果仍不代表最终处理结果，最终处理结果仍旧需要用户主动查询。
> 4. 如果等待处理结果：向xcs发送请求，等待xcs的最终处理结果
> * **一次请求，2次应答**： 第一次应答用于返回秘钥或uuid，如果用户等待处理结果，则还有第2次应答机会，返回处理结果。

* 重载 AllocMcpHandler ，将tcp发送buffer和接收buffer设置得很大，防止发送大数据包时的半包
* 区块分发中，先不考虑异常流程，先只按正常流程做；可能发生的异常如下：
> 1. 同一个anchor，多次发送begin应答
> 2. anchor发送了begin的成功应答后，和cbs的连接断开了；
> 3. achor发送的begin的成功应答后，没收到commit之前，session超时了；
> 4. 

* 经CC的查询: InterveningQuery 需要完成；
* 在事务中记录事务的完成时间，这个事可以在pts上，打包事务时做；

* 调整anchor的注释，调整cbs的策略

* CBS中累计的区块超过设定值时，则PTS停止接受新的事务， CBS中的待发送区块要存放到 mem-map缓存中，防止重启后丢失；(目前的实现是暂时存放在内存中)

* 所有使用HTS链接的地方，都要处理断链的场景，参照endorser实现。

* 将TAS和endorser的消息传递修改为函数调用。

* 新增一个可以动态指定大小的数组，并支持V编码，用来解决DSCShortVector（本质是std::vector）的效率问题。

# 第2期待做内容
* 同步
* 有一个用户信息迭代器，可以查询所有用户；
* 系统有一个Root用户，Root用户的开户不走SDK接口，是一个线下流程。网管系统登录VBH时，使用Root用户；网管系统针对登录用户的权限有自己的权限管理系统。
* cbs中排队区块超过设定的个数时，新到达的区块要写入文件；
* cbs中所有排队区块的个数超过限制时，要反向通知endorser停止接受所有的事务；
* 

---

* 注册用户过程中，使用临时生成的对称秘钥进行通信；
* 用户注册完成后，要有定时的秘钥更新机制；

---

* 在anchor端要保留一个区块信息的表：
> 1. 本anchor所持有的最新区块ID可以查取
> 2. 历史上所有拆分失败（存储到ucs和ics）或存储失败（存储到tcs）的区块都保留下来，定时将失败区块再次执行；
> 3. 所有拆分失败或存储失败的信息都需要上报到业务网管，由运维人员介入
> 4. 区块总体失败后，区块内哪些事务之前已经成功分发了，也和区块一起记录下来；将来再次分发时，可以不用重复分发了；

# 第3期待做内容
* 到user-commiter的路由目前实现为读取数据表，不支持动态更新；将来要支持网管对路由的动态更新；
* 客户端连接要支持半长连接（手机客户端到IDC或手机客户端到VBH）
* 新注册用户方法：
> 1. 为用户提供工具生成公私
> 2. 用户提交公钥注册用户
> 3. 服务端生成自己的私钥，在用户注册时把公钥返回给用户
> 4. 提供工具：用户可以将自己的私钥和服务端公钥合并为一个文件存储；

* 考虑客户端大量发送非法业务请求，导致的服务端session数暴涨。
* 在每个消息处理函数的入口处，加 DSC_INTF_LOG_INFO 日志
* 产品部署时，各服务器端要进行时间同步(NTP协议或SNTP协议)；时间同步时，可以考虑最终从标准授时服务器获取精准时间；


# 第4期待做内容
* 业务网管
> 1. 动态增加channel后，ucs和ics的路由可以动态更新
> 2. 动态增加peer后，order-cbs中的peer个数会更新
> 3. 分发区块失败时，要作为严重事件上报网管
> 4. 分发区块中的事务失败时，要能区分是哪个服务(ucs,ics,tcs)出现了问题

* 超大数据量裸设备存储：裸设备直接寻址时，支持的存储空间为2<sup>64</sup>B空间；在超大数据量时，需要考虑如何支持超过该数据量的存储空间。 __所有使用裸设备的地方都需要重新考虑__

